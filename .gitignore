# salary_calc.py
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Optional, Tuple

import pandas as pd


# -------------------------
# 기본 유틸
# -------------------------
def round_to_10won(x: float) -> int:
    """10원 단위로 반올림 (네이버 계산기처럼 끝자리 0에 맞추는 용도)"""
    return int(round(x / 10.0) * 10)


def clamp_int(x: int, lo: int, hi: int) -> int:
    return max(lo, min(hi, x))


def parse_int_like(s: str) -> Optional[int]:
    """
    '1,234' 같은 숫자를 int로.
    '-' 또는 빈 값이면 None.
    """
    s = s.strip()
    if not s or s == "-":
        return None
    # 숫자(콤마 포함)만 추출
    m = re.fullmatch(r"[0-9][0-9,]*", s)
    if not m:
        return None
    return int(s.replace(",", ""))


def extract_numbers_from_line(line: str) -> List[int]:
    """
    tax.txt 한 줄에서 숫자만 뽑기
    예:  "1,000" , "1,005" , - , - , "1,040" ...
    -> [1000, 1005, 1040, ...]
    """
    return [int(x.replace(",", "")) for x in re.findall(r"\d[\d,]*", line)]


# -------------------------
# tax.txt 로드 + 정리/검증
# -------------------------
def load_tax_table(path: str) -> pd.DataFrame:
    """
    tax.txt를 읽어서 DataFrame으로 만든다.
    가정:
      - 각 줄의 앞 2개 숫자 = base_from, base_to (단위: 천원일 가능성 높음)
      - 이후 숫자들 = 부양가족 수에 따른 근로소득세(간이세액)
      - '-' 는 누락으로 보고 None 처리 (파싱 단계에서는 숫자만 뽑히므로 누락은 자동으로 빠짐)
    """
    rows: List[List[Optional[int]]] = []

    with open(path, "r", encoding="utf-8") as f:
        for raw in f:
            line = raw.strip()
            if not line:
                continue

            # 숫자만 뽑는다 (누락 '-' 는 어차피 안 들어옴)
            nums = extract_numbers_from_line(line)
            if len(nums) < 2:
                continue

            base_from, base_to = nums[0], nums[1]
            taxes = nums[2:]  # dep별 값들 (없을 수도 있음)

            row: List[Optional[int]] = [base_from, base_to]
            # taxes는 길이가 줄마다 다를 수 있어서, 일단 그대로 넣고 나중에 패딩
            row.extend(taxes)
            rows.append(row)

    if not rows:
        raise ValueError("tax.txt에서 유효한 행을 하나도 읽지 못했습니다. 파일 형식을 확인하세요.")

    # 가장 긴 행 길이에 맞춰 패딩(None)
    max_len = max(len(r) for r in rows)
    for r in rows:
        r.extend([None] * (max_len - len(r)))

    # 컬럼 생성: base_from, base_to, dep_1, dep_2, ...
    dep_cols = [f"dep_{i}" for i in range(1, max_len - 1)]  # max_len = 2(base) + dep_n
    columns = ["base_from", "base_to"] + dep_cols

    df = pd.DataFrame(rows, columns=columns)

    # 정렬 + 중복 제거(혹시 모를)
    df = df.sort_values(["base_from", "base_to"]).drop_duplicates(subset=["base_from", "base_to"])

    return df


def audit_and_fix_tax_table(df: pd.DataFrame, verbose: bool = True) -> pd.DataFrame:
    """
    - 누락(None/NaN) 보간
    - 세액이 내려가면(단조 위반) 누적최대로 보정
    - 스파이크 의심(갑자기 확 튀는 변화) 로그
    """
    fixed = df.copy()

    dep_cols = [c for c in fixed.columns if c.startswith("dep_")]

    # 누락 보간: 앞/뒤 채움
    # (FutureWarning 피하려고 fillna(method=...) 대신 ffill/bfill 사용)
    for c in dep_cols:
        fixed[c] = fixed[c].ffill().bfill()

    # 단조 증가 위반 보정 (월급이 커지면 세액이 보통 증가/유지여야 함)
    # cummax로 "내려가는 구간"을 자동 복구
    for c in dep_cols:
        s = fixed[c]
        if s.isna().all():
            continue

        # 단조 위반 개수 체크
        diff = s.diff()
        drops = (diff < 0).sum()
        if verbose and drops > 0:
            print(f"[검출] 세액 감소(단조 위반) {drops}건 발견 -> {c} 누적최대(cummax)로 보정")

        fixed[c] = fixed[c].cummax()

    # 스파이크(급격한 증가) 의심: 변화량이 중앙값 대비 너무 큰 경우
    # (그냥 ‘의심’ 로그만 띄움)
    if verbose:
        for c in dep_cols:
            s = fixed[c].astype(float)
            d = s.diff().abs()
            med = d.median()
            if med == 0 or pd.isna(med):
                continue
            # 중앙값의 20배 이상이면 스파이크 후보
            spike_idx = fixed.index[d > (20 * med)].tolist()
            if spike_idx:
                # 너무 많으면 앞부분만 보여주기
                show = spike_idx[:10]
                for idx in show:
                    print(f"[의심] spike: {c}, 행 index={idx}")
                if len(spike_idx) > 10:
                    print(f"       ... (나머지 {len(spike_idx)-10}건 생략)")

    return fixed


def find_income_tax_monthly(df: pd.DataFrame, taxable_monthly_won: int, dependents: int) -> int:
    """
    간이세액표에서 월 소득세(근로소득세) 찾기
    - taxable_monthly_won을 '천원 단위'로 변환해 base 구간 찾음
    - dependents에 해당하는 dep_k 컬럼 사용
    """
    dep_cols = [c for c in df.columns if c.startswith("dep_")]
    if not dep_cols:
        # 표에 dep 컬럼이 없으면 세액 계산 불가
        return 0

    # dependents 최소 1(본인 포함)
    dependents = max(1, dependents)

    # 표의 dep 컬럼 범위 넘어가면 마지막 컬럼 사용
    dep_col = f"dep_{dependents}"
    if dep_col not in df.columns:
        dep_col = dep_cols[-1]

    # 천원 단위로 변환 (표가 1,000 ~ 1,005 이런 식이라 보통 천원 단위)
    x = taxable_monthly_won // 1000

    # 구간 매칭: base_from <= x < base_to
    hit = df[(df["base_from"] <= x) & (x < df["base_to"])]
    if hit.empty:
        # 범위 밖이면 가장 끝 구간으로 클램프
        if x < int(df["base_from"].min()):
            row = df.sort_values("base_from").iloc[0]
        else:
            row = df.sort_values("base_to").iloc[-1]
    else:
        row = hit.iloc[0]

    val = row[dep_col]
    if pd.isna(val):
        return 0
    return int(val)


# -------------------------
# 결과 계산
# -------------------------
@dataclass
class SalaryResult:
    pension: int
    health: int
    long_term_care: int
    employment: int
    income_tax: int
    local_tax: int
    annual_take_home: int
    monthly_take_home: int


def calc_salary(
    annual_salary: int,
    non_taxable_annual: int,
    dependents: int,
    tax_df: pd.DataFrame,
) -> SalaryResult:
    # 입력 정리
    annual_salary = max(0, int(annual_salary))
    non_taxable_annual = max(0, int(non_taxable_annual))
    dependents = max(1, int(dependents))

    # 비과세가 연봉보다 크면 말이 안 되니 자동으로 연봉까지 제한
    non_taxable_annual = min(non_taxable_annual, annual_salary)

    taxable_annual = annual_salary - non_taxable_annual
    taxable_monthly = taxable_annual / 12.0  # float
    taxable_monthly_won = int(round(taxable_monthly))

    # (실습용) 네이버 스샷에 맞춘 비율
    PENSION_RATE = 0.0475
    HEALTH_RATE = 0.03595
    LTC_RATE = 0.1314
    EMP_RATE = 0.009

    pension = round_to_10won(taxable_monthly * PENSION_RATE)
    health = round_to_10won(taxable_monthly * HEALTH_RATE)
    long_term = round_to_10won(health * LTC_RATE)
    employment = round_to_10won(taxable_monthly * EMP_RATE)

    # 근로소득세(간이세액표)
    income_tax = find_income_tax_monthly(tax_df, taxable_monthly_won, dependents)
    # 지방소득세 10%
    local_tax = round_to_10won(income_tax * 0.10)

    monthly_take_home = int(round(taxable_monthly)) - (pension + health + long_term + employment + income_tax + local_tax)
    annual_take_home = monthly_take_home * 12

    return SalaryResult(
        pension=pension,
        health=health,
        long_term_care=long_term,
        employment=employment,
        income_tax=income_tax,
        local_tax=local_tax,
        annual_take_home=annual_take_home,
        monthly_take_home=monthly_take_home,
    )


def print_like_naver(r: SalaryResult) -> None:
    print()
    print(f"국민연금(4.75%)        {r.pension:>10,} 원")
    print(f"건강보험(3.595%)       {r.health:>10,} 원")
    print(f"요양보험(13.14%)       {r.long_term_care:>10,} 원")
    print(f"고용보험(0.9%)         {r.employment:>10,} 원")
    print(f"근로소득세(간이세액)    {r.income_tax:>10,} 원")
    print(f"지방소득세(10%)         {r.local_tax:>10,} 원")
    print(f"년 예상 실수령액        {r.annual_take_home:>10,} 원")
    print(f"월 환산금액            {r.monthly_take_home:>10,} 원")


# -------------------------
# 실행부
# -------------------------
if __name__ == "__main__":
    # ✅ tax.txt는 이 파일(salary_calc.py)과 "같은 폴더"에 있어야 함
    base_dir = Path(__file__).resolve().parent
    tax_path = base_dir / "tax.txt"

    if not tax_path.exists():
        raise FileNotFoundError(f"tax.txt를 찾을 수 없습니다: {tax_path}")

    # 1) 세액표 로드
    df = load_tax_table(str(tax_path))

    # 2) 이상치 검출 + 자동 보정
    df = audit_and_fix_tax_table(df, verbose=True)

    # 3) 입력(모르면 엔터 -> 기본값)
    try:
        annual_salary = int((input("연봉(원) 입력 [예: 36000000] : ").strip() or "36000000"))
        non_taxable_annual = int((input("비과세액(연, 원) 입력 [모르면 0] : ").strip() or "0"))
        dependents = int((input("부양가족수(본인포함) 입력 [모르면 1] : ").strip() or "1"))
    except ValueError:
        print("숫자로만 입력해야 합니다.")
        raise

    # 4) 계산 + 출력
    result = calc_salary(annual_salary, non_taxable_annual, dependents, df)
    print_like_naver(result)
